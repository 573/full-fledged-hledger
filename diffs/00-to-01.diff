diff -X .gitignore -Naurb ././00-empty/2017.journal ././01-getting-started/2017.journal
--- ././00-empty/2017.journal	1970-01-01 01:00:00.000000000 +0100
+++ ././01-getting-started/2017.journal	2019-02-06 23:33:02.000000000 +0000
@@ -0,0 +1 @@
+;; This journal is for the current year
diff -X .gitignore -Naurb ././00-empty/all.journal ././01-getting-started/all.journal
--- ././00-empty/all.journal	1970-01-01 01:00:00.000000000 +0100
+++ ././01-getting-started/all.journal	2019-02-06 23:33:02.000000000 +0000
@@ -0,0 +1 @@
+!include 2017.journal
diff -X .gitignore -Naurb ././00-empty/export/2017-balance-sheet.txt ././01-getting-started/export/2017-balance-sheet.txt
--- ././00-empty/export/2017-balance-sheet.txt	1970-01-01 01:00:00.000000000 +0100
+++ ././01-getting-started/export/2017-balance-sheet.txt	2019-02-08 23:13:43.823726830 +0000
@@ -0,0 +1,15 @@
+Balance Sheet -
+
+             ||  
+=============++==
+ Assets      ||  
+-------------++--
+-------------++--
+             ||  
+=============++==
+ Liabilities ||  
+-------------++--
+-------------++--
+             ||  
+=============++==
+ Net:        ||  
diff -X .gitignore -Naurb ././00-empty/export/2017-cash-flow.txt ././01-getting-started/export/2017-cash-flow.txt
--- ././00-empty/export/2017-cash-flow.txt	1970-01-01 01:00:00.000000000 +0100
+++ ././01-getting-started/export/2017-cash-flow.txt	2019-02-08 23:22:10.780250243 +0000
@@ -0,0 +1,8 @@
+Cashflow Statement -
+
+            || - 
+============++===
+ Cash flows ||   
+------------++---
+------------++---
+            ||   
diff -X .gitignore -Naurb ././00-empty/export/2017-closing.journal ././01-getting-started/export/2017-closing.journal
--- ././00-empty/export/2017-closing.journal	1970-01-01 01:00:00.000000000 +0100
+++ ././01-getting-started/export/2017-closing.journal	2019-02-08 23:22:10.780250243 +0000
@@ -0,0 +1,3 @@
+2017/12/31 closing balances
+    equity:closing balances               0
+
diff -X .gitignore -Naurb ././00-empty/export/2017-income-expenses.txt ././01-getting-started/export/2017-income-expenses.txt
--- ././00-empty/export/2017-income-expenses.txt	1970-01-01 01:00:00.000000000 +0100
+++ ././01-getting-started/export/2017-income-expenses.txt	2019-02-08 23:13:43.819726764 +0000
@@ -0,0 +1,15 @@
+Income Statement -
+
+          || - 
+==========++===
+ Revenues ||   
+----------++---
+----------++---
+          ||   
+==========++===
+ Expenses ||   
+----------++---
+----------++---
+          ||   
+==========++===
+ Net:     ||   
diff -X .gitignore -Naurb ././00-empty/export/export.hs ././01-getting-started/export/export.hs
--- ././00-empty/export/export.hs	1970-01-01 01:00:00.000000000 +0100
+++ ././01-getting-started/export/export.hs	2019-02-08 23:13:27.495453072 +0000
@@ -0,0 +1,211 @@
+#!/usr/bin/env stack
+-- stack --resolver lts-12.4 script --package shake,directory
+import Development.Shake
+import Development.Shake.FilePath
+import Data.List
+import Text.Printf
+import Control.Monad
+import System.IO
+import System.Directory as D
+
+--
+-- Range of years to report. You would typically want all the years you have data for.
+--
+first   = 2017 :: Int
+current = 2017
+all_years=[first..current]
+
+--
+-- Input file naming scheme
+--
+input y = printf "../%s.journal" y
+
+--
+-- File naming scheme
+-- It assumes that you do not have similarly-named journals anywhere among files !included
+-- from you yearly journals
+--
+transactions      y = y++"-all.journal"
+income_expenses   y = y++"-income-expenses.txt"
+balance_sheet     y = y++"-balance-sheet.txt"
+cash_flow         y = y++"-cash-flow.txt"
+accounts          y = y++"-accounts.txt"
+unknown           y = y++"-unknown.journal"
+-- which accounts to include in opening/closing reports
+open_close_account_query = "assets|liabilities|debts"
+closing_balances  y = y++"-closing.journal"
+opening_balances  y = y++"-opening.journal"
+
+--
+-- Defining the full set of reports and journals to be generated
+--
+reports = 
+  concat [ [ transactions         (show y) | y <- all_years ]
+         , [ accounts             (show y) | y <- all_years ]
+         , [ income_expenses      (show y) | y <- all_years ]
+         , [ balance_sheet        (show y) | y <- all_years ]
+         , [ cash_flow            (show y) | y <- all_years ]
+         , [ unknown              (show y) | y <- all_years ]
+         , concat [ autogenerated_inputs (show y) | y <- all_years ]
+         ]
+
+-- Each yearly journal will need opening and closing balances journal generated
+autogenerated_inputs year = 
+  let
+    open_close =
+      case year of
+        -- opening balances are not generated for the first year
+        x | x == show first   -> [closing_balances year]
+        -- closing balances are not generated for the last year        
+        x | x == show current -> [opening_balances year]
+        otherwise -> [opening_balances year, closing_balances year]
+  in
+    open_close
+
+main = 
+  shakeArgs shakeOptions 
+  export_all
+  
+export_all = do
+  want reports
+
+  -- This is a global lock that allow only one job to run when fake empty closing balances file
+  -- had been (temporary) created
+  fakeEmptyIncludes <- newResource "empty *-closing.journal" 1
+
+  -- Ensure that give files are present, and replace any missing ones with empty files.
+  -- Run IO action f, and remove any of the auto-generated files that are stil empty.
+  --
+  -- Typical use-case is processing of a yearly journal to generate closing balances transaction,
+  -- but yearly journal itself will '!include' the closing balances transaction file. In order
+  -- to escape from Catch 22 situation we generate empty closing balances file, generate closing
+  -- balances transaction, put it into the file we just generated.
+  let ensurePresent files f = do
+        -- ensure all autogenerated files exists
+        fakes <- liftIO $ filterM (\file -> do e<- D.doesFileExist file; return (not e)) files
+        if fakes == [] 
+          then f
+          else withResource fakeEmptyIncludes 1 $ do
+            () <- cmd "touch" fakes
+            result <- f
+            -- remove any still-empty autogenerate files we just created
+            to_remove <- liftIO $ filterM isEmpty fakes
+            () <- if to_remove ==[] 
+                  then return () 
+                  else do
+                    cmd "rm" ("-f":to_remove)
+            return result
+  
+  -- Generate the list of all !includes for the given .journal file, recursively
+  year_inputs <- newCache $ \year -> do
+    let file = input year
+    ensurePresent (autogenerated_inputs year) $ getIncludes file -- file itself will be included here
+
+  -- Run hledger command on a given yearly file. Year is extracted from output file name.
+  -- To generate '2017-balances', we will process '2017.journal'
+  let hledger_process_year args out = do  
+        let year = head $ split out
+        deps <- year_inputs year
+        need deps
+        (Stdout output) <- cmd "hledger" ("-f" : input year : args)
+        writeFileChanged out output
+  
+  (transactions "//*") %> hledger_process_year ["print"]
+  
+  (accounts "//*") %> hledger_process_year ["accounts"]
+
+  (income_expenses "//*") %> hledger_process_year ["is","--flat"]
+
+  (balance_sheet "//*") %> hledger_process_year ["balancesheet","not:desc:(closing balances)"]
+
+  (cash_flow "//*") %> hledger_process_year ["cashflow","not:desc:(opening balances)","not:desc:(closing balances)"]
+
+  (unknown "//*") %> hledger_process_year ["print", "unknown"]
+
+  (closing_balances "//*") %> \out -> do  
+    let year = head $ split out
+    deps <- year_inputs year
+    -- year_inputs will include the output file for this rule, lets exclude it
+    need $ filter (not.((takeFileName out) `isSuffixOf`)) $ deps
+    ensurePresent (autogenerated_inputs year) $ do 
+      (Stdout output) <- 
+        cmd "hledger" 
+          ["-f",input year,"equity",open_close_account_query,"not:desc:(closing balances)","-e",show (1+(read year)),"-I","--closing"]
+      writeFileChanged out output
+  
+  (opening_balances "//*") %> \out -> do  
+    let year = head $ split out
+    let prev_year = show ((read year)-1)
+    deps <- year_inputs prev_year
+    need deps
+    (Stdout output) <- 
+      cmd "hledger" 
+      ["-f",input prev_year,"equity",open_close_account_query,"not:desc:(closing balances)","-e",year,"--opening"]
+    writeFileChanged out output
+
+
+  ------------    
+  -- Importing
+  ------------
+  let extraDeps file = []
+
+  let extraInputs file = []
+
+  -- To produce <importdir>/csv/filename.csv, look for <importdir>/in/filename.csv and
+  -- process it with <importdir>/in2csv
+  let in2csv out = do
+        let (csv_dir, file) = splitFileName out
+        let source_dir = parentOf "csv" csv_dir
+        let in_dir = replace "csv" "in" csv_dir
+        possibleInputs <- getDirectoryFiles in_dir [file -<.> "*"]
+        let inputs = 
+              case possibleInputs of
+                [] -> error $ "no inputs for " ++ show file
+                _ -> map (in_dir</>) $ possibleInputs ++ (extraInputs file) 
+        let deps = map (source_dir </>) $ extraDeps out
+        need $ (source_dir </> "in2csv"):(inputs ++ deps)
+        (Stdout output) <- cmd (Cwd source_dir) "./in2csv" (map (makeRelative source_dir) inputs)
+        writeFileChanged out output
+
+  -- To produce <importdir>/journal/filename.journal, look for <importdir>/csv/filename.csv and
+  -- process it with <importdir>/csv2journal
+  let csv2journal out = do
+        let (journal_dir, file) = splitFileName out
+        let source_dir = parentOf "journal" journal_dir
+        let csv_dir = replace "journal" "csv" journal_dir
+        let input = csv_dir </> (file -<.> "csv")
+        let deps = map (source_dir </>) $ extraDeps out
+        need $ (source_dir </> "csv2journal"):(input:deps)
+        (Stdout output) <- cmd (Cwd source_dir) "./csv2journal" [makeRelative source_dir input]
+        writeFileChanged out output
+
+  return ()
+  where
+    -- To get included files, look for '!include'. Note that we cant use "hledger files", as
+    -- some of the requested includes might be generated by this file and might not exist yet.
+    getIncludes file = do
+      src <- liftIO $ readFile file
+      let includes = [ensureFullPath x | x <- lines src, Just x <- [stripPrefix "!include " x]]
+      return (file:includes)
+
+    ensureFullPath x  
+      | "/" `isPrefixOf` x = x
+      | "./export/" `isPrefixOf` x, Just y <- stripPrefix "./export/" x = y
+      | otherwise = "../" ++ x 
+    
+    split s = takeWhile (/="") $ unfoldr (Just . head . lex) $ takeFileName s
+
+    isEmpty :: FilePath -> IO Bool
+    isEmpty fp = do
+      sz <- withFile fp ReadMode hFileSize
+      return (sz == 0)
+
+-- Take "dirpath" and return parent dir of "subdir" component
+parentOf :: FilePath -> FilePath -> FilePath
+parentOf subdir dirpath = 
+  joinPath $ takeWhile (/= subdir) $ splitDirectories dirpath 
+
+-- Take "dirpath" and replace "this" dir component with "that" dir component
+replace :: FilePath -> FilePath -> FilePath -> FilePath
+replace this that dirpath = 
+  joinPath $ map (\subdir -> if subdir == this then that else subdir) $ splitDirectories dirpath   
diff -X .gitignore -Naurb ././00-empty/export.sh ././01-getting-started/export.sh
--- ././00-empty/export.sh	1970-01-01 01:00:00.000000000 +0100
+++ ././01-getting-started/export.sh	2018-08-03 22:54:15.000000000 +0100
@@ -0,0 +1,2 @@
+#!/bin/bash
+$(dirname $0)/export/export.hs -C $(dirname $0)/export -j --color "$@"
